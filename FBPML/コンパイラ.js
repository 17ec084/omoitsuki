//目的: FBPMLで書かれた文字列を多次元配列に変換する
//条件: 先にコードクラス.jsが読み込まれること





function FBPML(文字列)
{
    let コード = new コードType(文字列);
    let 配列 = [];
    while (コード.が残っている())
    {
        コード.の先頭からホワイトスペースを除去する();
        コード.の先頭が次に一致しないならエラーを投げ一致するなら進める("---", "<FBPML>");

        文_ = 文(コード); //テスト済み
        配列.push(["---", 文_]);
    }
    return 配列;
}



function 文(コード) //テスト済み
{
    let 配列 = [];
    let 新規の穴_, 既知の穴_, htmlコード_;
    コード.の先頭からホワイトスペースを除去する();

    while (
        コード.の先頭が次に一致しない("---")
        &&
        コード.が残っている()
    )
    {
        let セーブデータ = コード.をセーブする();
        try
        {
            新規の穴_    = 新規の穴  (コード); //テスト済み
            配列.push(["新規の穴",   新規の穴_]);
            continue;
        }
        catch (error){コード.をロードする(セーブデータ);}
        try
        {
            既知の穴_    = 既知の穴  (コード); //テスト済み
            配列.push(["既知の穴",   既知の穴_]);
            continue;
        }
        catch (error){コード.をロードする(セーブデータ);}
        try
        {
             htmlコード_ = htmlコード(コード); //テスト済み
             配列.push(["htmlコード", htmlコード_]);
             continue;
        } 
        catch (error){コード.をロードする(セーブデータ);}
        throw new Error("すべての非終端記号に拒否されました 於 <文>");
    }
    return 配列;
}





function 新規の穴(コード) //テスト済み
{
    let 番号開始    = "";
    let htmlコード_ = "";
    let 番号終了    = "";

    コード.の先頭からホワイトスペースを除去する();
    コード.の先頭が次に一致しないならエラーを投げ一致するなら進めてホワイトスペースを除去する("<", "<新規の穴>");

    while(コード.の先頭1文字が次のいずれかに一致する("0123456789"))
        番号開始 += コード.の先頭から次に指定する文字数だけ取り出す(1);
    コード.の先頭からホワイトスペースを除去する();

    コード.の先頭が次に一致しないならエラーを投げ一致するなら進める(">", "<新規の穴>");



    const セーブデータ = コード.をセーブする();
    try{htmlコード_ = htmlコード(コード);} //テスト済み
    catch (error){コード.をロードする(セーブデータ);}

    
    コード.の先頭からホワイトスペースを除去する();
    コード.の先頭が次に一致しないならエラーを投げ一致するなら進めてホワイトスペースを除去する("<", "新規の穴");
    コード.の先頭が次に一致しないならエラーを投げ一致するなら進めてホワイトスペースを除去する("/", "新規の穴"); 
    
    while(コード.の先頭1文字が次のいずれかに一致する("0123456789"))
        番号終了 += コード.の先頭から次に指定する文字数だけ取り出す(1);
    コード.の先頭からホワイトスペースを除去する();

    コード.の先頭が次に一致しないならエラーを投げ一致するなら進める(">", "<新規の穴>");

    return [
        "<",
        番号開始,
        ">",
        htmlコード_,
        "</",
        番号終了,
        ">"
    ]

}



function 既知の穴(コード) //テスト済み
{
    let 番号 = "";
    コード.の先頭からホワイトスペースを除去する();
    コード.の先頭が次に一致しないならエラーを投げ一致するなら進めてホワイトスペースを除去する("<", "既知の穴");

    while(コード.の先頭1文字が次のいずれかに一致する("0123456789"))
        番号 += コード.の先頭から次に指定する文字数だけ取り出す(1);
    コード.の先頭からホワイトスペースを除去する();

    コード.の先頭が次に一致しないならエラーを投げ一致するなら進めてホワイトスペースを除去する("/", "既知の穴");
    コード.の先頭が次に一致しないならエラーを投げ一致するなら進めてホワイトスペースを除去する(">", "既知の穴");

    return [
        "<",
        番号,
        "/>"
    ]
}



function htmlコード(コード) //テスト済み
//新規の穴の開始または終了タグを含まず、かつ既知の穴を含まないような、「---」の出現しない任意の文字列
{
    コード文字列 = コード.をセーブする();
    let 文字列 = "";
    let _, html, 穴;

    var tmp;

    if (コード文字列 === "</html>")
        tmp = 1;
    while (
        新規の穴の開始タグを含まない(文字列)
        &&
        新規の穴の終了タグを含まない(文字列)
        &&
        既知の穴のタグを含まない(文字列)
//        &&
//        コード文字列.length != 0
    )
    {
        文字列 += コード文字列.substr(0, 1);
        コード文字列 = コード文字列.slice(1);
        if (文字列.match(/---$/))
        {
            htmlコード_ = 文字列.substr(0, 文字列.length-3);
            コード.をロードする("---" + コード文字列);
            return htmlコード_;
        }
        if (コード文字列.length == 0)
        {
            htmlコード_ = 文字列;
            コード.をロードする(コード文字列);
            return htmlコード_;
        }
        
    }/*
    try
    {
        [_, htmlコード_, 穴] = 文字列.match(/((?:.|\n)*)(<[^<]*$)/);
        コード.をロードする(穴+コード文字列);
    }
    catch (error)//正規表現にマッチしない(＝穴に関するタグが出現せずに文字列全体が終了した場合)
    {
        htmlコード_ = 文字列;
        コード.をロードする(コード文字列);
    }*/
    [_, htmlコード_, 穴] = 文字列.match(/((?:.|\n)*)(<[^<]*$)/);
//    [_, htmlコード_, 穴] = 文字列.match(/((?:[^\-]|(?:-[^\-])|(?:--[^\-]))*)(<[^<]*$)/);
    コード.をロードする(穴+コード文字列);
    return htmlコード_;

}

function 新規の穴の開始タグを含まない(文字列)//テスト済み(簡易)
{
    return 文字列.match(/<[ \t\r\n]*[0-9]+[ \t\r\n]*>/) == null;
}


function 新規の穴の終了タグを含まない(文字列)//テスト済み(簡易)
{
    return 文字列.match(/<[ \t\r\n]*\/[ \t\r\n]*[0-9]+[ \t\r\n]*>/) == null;
}

function 既知の穴のタグを含まない(文字列)//テスト済み
{
    return 文字列.match(/<[ \t\r\n]*[0-9]+[ \t\r\n]*\/[ \t\r\n]*>/) == null;    
}


